#!/usr/bin/env ruby

require 'mysql'
require 'optparse'
require 'ostruct'

class DatabaseFinder
  attr_accessor :application, :locations, :exists_at, :located_at, :regex, :dbname, :dbuser, :dbpass, :dbhost, :dbtableprefix
  
  @@supported_applications = [:joomla, :wordpress, :drupal, :phpbb, :gallery, :zencart, :mediawiki]
  
  @@app_metadata = {}
  @@app_metadata[:drupal] = {
    :locations => ["sites/default/settings.php"],
    :regex => {
      :dbname => Regexp.new("^\\$db_url.*?\\/\\/.*?\\/(.*?)'"),
      :dbuser => Regexp.new("^\\$db_url.*?\\/\\/(.*)?:.*?'"),
      :dbpass => Regexp.new("^\\$db_url.*?\\/\\/.*?:(.*)?@.*?'"),
      :dbhost => Regexp.new("^\\$db_url.*?\\/\\/.*?@(.*)?\\/.*?'"),
    },
  }
  @@app_metadata[:gallery] = {
    :locations => ["config.php"],
    :regex => {
      :dbname => Regexp.new("\\$storeConfig\\['database'.*?'(.*?)'"),
      :dbuser => Regexp.new("\\$storeConfig\\['username'.*?'(.*?)'"),
      :dbpass => Regexp.new("\\$storeConfig\\['password'.*?'(.*?)'"),
      :dbhost => Regexp.new("\\$storeConfig\\['hostname'.*?'(.*?)'"),
    },
  }
  @@app_metadata[:joomla] = {
    :locations => ["configuration.php"],
    :regex => {
      :dbname => Regexp.new("\\$db\\s*=\\s*'(.*?)'"),
      :dbuser => Regexp.new("\\$user\\s*=\\s*'(.*?)'"),
      :dbpass => Regexp.new("\\$password\\s*=\\s*'(.*?)'"),
      :dbhost => Regexp.new("\\$host\\s*=\\s*'(.*?)'"),
    },
  }
  @@app_metadata[:mediawiki] = {
    :locations => ["LocalSettings.php"],
    :regex => {
      :dbname => Regexp.new("\\$wgDBname\\s*=\\s*'(.*?)'"),
      :dbuser => Regexp.new("\\$wgDBuser\\s*=\\s*'(.*?)'"),
      :dbpass => Regexp.new("\\$wgDBpassword\\s*=\\s*'(.*?)'"),
      :dbhost => Regexp.new("\\$wgDBserver\\s*=\\s*'(.*?)'"),
    },
  }
  @@app_metadata[:phpbb] = {
    :locations => ["config.php"],
    :regex => {
      :dbname => Regexp.new("dbname\\s*=\\s*'(.*?)'"),
      :dbuser => Regexp.new("dbuser\\s*=\\s*'(.*?)'"),
      :dbpass => Regexp.new("dbpasswd\\s*=\\s*'(.*?)'"),
      :dbhost => Regexp.new("dbhost\\s*=\\s*'(.*?)'"),
    },
  }
  @@app_metadata[:wordpress] = {
    :locations => ["wp-config.php"],
    :regex => {
      :dbname => Regexp.new("DB_NAME'.*?'(.*?)'"),
      :dbuser => Regexp.new("DB_USER'.*?'(.*?)'"),
      :dbpass => Regexp.new("DB_PASSWORD'.*?'(.*?)'"),
      :dbhost => Regexp.new("DB_HOST'.*?'(.*?)'"),
      :dbtableprefix => Regexp.new("\\$table_prefix\\s*=\\s*'(.*?)'"),
    },
  }
  @@app_metadata[:zencart] = {
    :locations => ["includes/configure.php"],
    :regex => {
      :dbname => Regexp.new("DB_DATABASE'.*?'(.*?)'"),
      :dbuser => Regexp.new("DB_SERVER_USERNAME'.*?'(.*?)'"),
      :dbpass => Regexp.new("DB_SERVER_PASSWORD'.*?'(.*?)'"),
      :dbhost => Regexp.new("DB_SERVER'.*?'(.*?)'"),
    },
  }
  
  def initialize(app)
    @exists_at = []
    @dbname = nil
    @dbuser = nil
    @dbpass = nil
    @dbhost = nil
    self.application = app
    self.locations = @@app_metadata[@application][:locations]
    @regex = @@app_metadata[@application][:regex]
  end
  
  def application=(app)
    a = String(app).downcase.to_sym
    if @@supported_applications.include?(a)
      instance_variable_set(:@application, a)
    else
      raise "That application is not supported yet."
    end
  end
  
  def find_db_info
    locate_files
    @exists_at.each do |file|
      # puts "Searching '#{file}' for db connection info..."
      File.foreach(file) do |line|
        @dbname ||= @regex[:dbname].match(line)[1] if @regex[:dbname] === line
        @dbuser ||= @regex[:dbuser].match(line)[1] if @regex[:dbuser] === line
        @dbpass ||= @regex[:dbpass].match(line)[1] if @regex[:dbpass] === line
        @dbhost ||= @regex[:dbhost].match(line)[1] if @regex[:dbhost] === line
        @dbtableprefix ||= @regex[:dbtableprefix].match(line)[1] if @regex[:dbtableprefix] === line && @regex.has_key?(:dbtableprefix)
        @located_at = file if @dbname
      end
    end
  end
  
  def manual_connection_string
    "mysql -u #{@dbuser} -p#{@dbpass} -h #{@dbhost} #{@dbname}"
  end
  
  private
    def locate_files
      @locations.each do |loc|
        if File.exists?(loc)
          @exists_at << loc
        end
      end
    end
end


def fetch_args(args)
  options = OpenStruct.new
  options.verbose = false
  options.app_type = :wordpress
  
  ARGV.options do |opts|
    opts.banner = "Usage:  #{File.basename($PROGRAM_NAME)} [options]"

    opts.separator " "
    opts.separator "Specific options:"

    opts.on( "-v", "--verbose", "Display more detailed information." ) do
      options.verbose = true
    end

    opts.separator " "
    opts.separator "Misc:"

    opts.on( "-h", "--help", "Show this message." ) do
      puts opts
      exit
    end

    opts.separator " "

    begin
      opts.parse!(args)
    rescue OptionParser::InvalidOption => e
      puts e
      puts opts
      exit(1)
    end
  end
  options
end

def verbose_puts(text)
  puts " v #{text}"
end

def verbose(text, verbose)
  verbose_puts(text) if verbose
end

def do_query(db, query, verbose)
  if verbose
    verbose_puts("EXECUTING: #{query}")
    output = db.query(query)
    verbose_puts("#{db.affected_rows} row(s) affected.")
    return output
  else
    return db.query(query)
  end
end

def switch_theme!
  @@options ||= fetch_args(ARGV)
  
  @df = DatabaseFinder.new(@@options.app_type)
  @df.find_db_info
  
  begin
    puts "Disabling current theme..."
    verbose("Connecting to '#{@df.dbname}' database...", @@options.verbose)
    db = Mysql::new(@df.dbhost, @df.dbuser, @df.dbpass, @df.dbname)
    
    verbose("Looking for theme...", @@options.verbose)
    query = "SELECT option_value from #{@df.dbtableprefix}options WHERE option_name='template';"
    rows = do_query(db, query, @@options.verbose)
  
    if db.affected_rows == 0
      puts "    No theme was found."
      exit
    else
      theme = nil
      rows.each do |template|
        theme = template
      end
      
      query = "SELECT option_value from #{@df.dbtableprefix}options WHERE option_name='current_theme';"
      rows = do_query(db, query, @@options.verbose)
      theme_name = nil
      rows.each do |name|
        theme_name = name
      end
      
      verbose("Switching to 'default' theme...", @@options.verbose)
      
      query = "UPDATE #{@df.dbtableprefix}options SET option_value='default' WHERE option_name='template' OR option_name='stylesheet';"
      do_query(db, query, @@options.verbose)
      
      query = "UPDATE #{@df.dbtableprefix}options SET option_value='WordPress Default' WHERE option_name='current_theme';"
      do_query(db, query, @@options.verbose)
      print "    Revert to the original theme? "
      revert = gets.chomp
    end
    
    if ["y","Y","yes"].include?(revert)
      puts "    * Reverting theme..."
      verbose("Switching to '#{theme}' theme...", @@options.verbose)
      
      query = "UPDATE #{@df.dbtableprefix}options SET option_value='#{theme}' WHERE option_name='template' OR option_name='stylesheet' OR option_name='current_theme';"
      do_query(db, query, @@options.verbose)
      
      query = "UPDATE #{@df.dbtableprefix}options SET option_value='#{theme_name}' WHERE option_name='current_theme';"
      do_query(db, query, @@options.verbose)
      
      puts "    * Theme now set to: '#{theme}'"
    else
      puts "    * Ok. Leaving the default theme in place."
    end
  rescue Mysql::Error => e
    puts "        Error code: #{e.errno}"
    puts "     Error message: #{e.error}"
    puts "    Error SQLSTATE: #{e.sqlstate}" if e.respond_to?("sqlstate")
  ensure
    verbose("Closing database connection...", @@options.verbose)
    db.close if db
  end
end

switch_theme!